//go:build ignore

package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

type CodeDef struct {
	ConstName string
}

func main() {
	// 解析命令行参数
	inputFile := flag.String("input", "", "input file path")
	outputFile := flag.String("output", "", "output file path")
	translationDirFlag := flag.String("translationDir", "./", "translation files output directory")
	flag.Parse()

	if *inputFile == "" || *outputFile == "" {
		fmt.Println("Usage: go run generator.go -input <inputfile> -output <outputfile> [-translationDir <translationDir>]")
		os.Exit(1)
	}

	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, *inputFile, nil, parser.ParseComments)
	if err != nil {
		panic(err)
	}

	// 获取输入文件的包名
	pkgName := node.Name.Name

	codes := extractCodes(node)

	generateOutput(codes, pkgName, *outputFile)

	filesArray := parseFilesArray(node)
	translationMap := parseTranslationMap(node)

	generateTranslationFiles(translationMap, filesArray, *translationDirFlag)
}

func extractCodes(node *ast.File) []CodeDef {
	var codes []CodeDef

	for _, decl := range node.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.CONST {
			continue
		}

		isRspCodeBlock := false
		for _, spec := range genDecl.Specs {
			valueSpec, ok := spec.(*ast.ValueSpec)
			if !ok {
				continue
			}

			// Check if this is a RspCode type block
			if valueSpec.Type != nil {
				if ident, ok := valueSpec.Type.(*ast.Ident); ok && ident.Name == "RspCode" {
					isRspCodeBlock = true
				}
			}

			if isRspCodeBlock {
				for _, name := range valueSpec.Names {
					codes = append(codes, CodeDef{
						ConstName: name.Name,
					})
				}
			}
		}
	}

	return codes
}

func isRspCodeType(expr ast.Expr) bool {
	if ident, ok := expr.(*ast.Ident); ok {
		return ident.Name == "RspCode"
	}
	return false
}

func generateOutput(codes []CodeDef, pkgName string, outputFile string) {
	tmpl := `// Code generated by go generate; DO NOT EDIT.

package {{.Pkg}}

var codeToName = map[RspCode]string{
	{{- range .Codes}}
	{{.ConstName}}: "{{.ConstName}}",{{end}}
}

// Msg 获取错误码对应的常量名
func (code RspCode) Msg() string {
	if name, ok := codeToName[code]; ok {
		return name
	}
	return "UNKNOWN_CODE"
}
`

	f, err := os.Create(outputFile)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	t := template.Must(template.New("").Parse(tmpl))
	err = t.Execute(f, struct {
		Pkg   string
		Codes []CodeDef
	}{
		Pkg:   pkgName,
		Codes: codes,
	})

	if err != nil {
		panic(err)
	}
}

func parseFilesArray(node *ast.File) []string {
	var filesArray []string
	for _, decl := range node.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.VAR {
			continue
		}
		for _, spec := range genDecl.Specs {
			valueSpec := spec.(*ast.ValueSpec)
			if len(valueSpec.Names) > 0 && valueSpec.Names[0].Name == "files" {
				compositeLit, ok := valueSpec.Values[0].(*ast.CompositeLit)
				if !ok {
					continue
				}
				for _, elt := range compositeLit.Elts {
					basicLit, ok := elt.(*ast.BasicLit)
					if !ok || basicLit.Kind != token.STRING {
						continue
					}
					filesArray = append(filesArray, strings.Trim(basicLit.Value, "\""))
				}
				return filesArray
			}
		}
	}
	return filesArray
}

func parseTranslationMap(node *ast.File) map[string]string {
	translationMap := make(map[string]string)

	for _, decl := range node.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.VAR {
			continue
		}
		for _, spec := range genDecl.Specs {
			valueSpec, ok := spec.(*ast.ValueSpec)
			if !ok || len(valueSpec.Names) == 0 || valueSpec.Names[0].Name != "translation" {
				continue
			}

			compositeLit, ok := valueSpec.Values[0].(*ast.CompositeLit)
			if !ok {
				continue
			}

			for _, elt := range compositeLit.Elts {
				keyValueExpr, ok := elt.(*ast.KeyValueExpr)
				if !ok {
					continue
				}

				// Get the code name from the key
				var rspCodeName string
				if ident, ok := keyValueExpr.Key.(*ast.Ident); ok {
					rspCodeName = ident.Name
				} else {
					continue
				}

				// Get the translation string
				basicLit, ok := keyValueExpr.Value.(*ast.BasicLit)
				if !ok || basicLit.Kind != token.STRING {
					continue
				}
				translationValue := strings.Trim(basicLit.Value, "\"")
				translationMap[rspCodeName] = translationValue
			}

			return translationMap
		}
	}
	return translationMap
}

func generateTranslationFiles(translationMap map[string]string, filesArray []string, translationDir string) {
	// Create the directory if it doesn't exist
	if err := os.MkdirAll(translationDir, 0755); err != nil {
		fmt.Printf("Error creating directory %s: %v\n", translationDir, err)
		return
	}

	for index, file := range filesArray {
		langTranslations := make(map[string]string)
		for codeName, translationStr := range translationMap {
			parts := strings.Split(translationStr, "|")
			langTranslation := ""
			if index < len(parts) {
				langTranslation = parts[index]
			} else if len(parts) > 0 {
				langTranslation = parts[0] // Default to the first language if not enough translations
			}
			langTranslations[codeName] = langTranslation
		}

		outputFilePath := filepath.Join(translationDir, file)
		f, err := os.Create(outputFilePath)
		if err != nil {
			fmt.Printf("Error creating translation file %s: %v\n", outputFilePath, err)
			continue
		}

		encoder := jsoniter.NewEncoder(f)
		encoder.SetIndent("", "    ") // Pretty print JSON
		err = encoder.Encode(langTranslations)
		if err != nil {
			fmt.Printf("Error encoding JSON to file %s: %v\n", outputFilePath, err)
		} else {
			fmt.Printf("Generated translation file: %s\n", outputFilePath)
		}
		f.Close()
	}
}

// 定义 RspCode 类型，为了能通过编译
type RspCode int
